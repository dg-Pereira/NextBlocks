{"version":3,"file":"lib.min.js","sources":["../src/lib.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/env\n * @copyright   2023 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/* globals Blockly */\n/* globals javascript */\n\n/**\n * Injects the box for inserting the program input below the blockly area\n * @param {Number} i the index of the input box, to avoid repetition of ids\n */\nexport const injectInputBox = (i) => {\n    // Create input box for program input\n    const inputBox = document.createElement('input');\n    inputBox.setAttribute('type', 'text');\n    inputBox.setAttribute('id', 'programInputBox' + i);\n\n    // Create button to submit input\n    const submitButton = document.createElement('button');\n    submitButton.setAttribute('id', 'programInputButton' + i);\n    submitButton.setAttribute('type', 'button');\n    submitButton.innerHTML = 'Submit';\n\n    // Insert input box and button below blockly area\n    const blocklyDiv = document.getElementById('blocklyDiv');\n    blocklyDiv.insertAdjacentElement('afterend', inputBox);\n    inputBox.insertAdjacentElement('afterend', submitButton);\n};\n\n/**\n * Inserts the new program code in the code div below the blockly area, replacing the old one if it exists\n * @param {string} code the new program code to be displayed\n * @param {number} inputFuncDecsN the number of forced input function declarations\n */\nexport const replaceCode = (code, inputFuncDecsN) => {\n    const codeDiv = document.getElementById('codeDiv');\n    codeDiv.innerHTML = formatCodeHTML(code, inputFuncDecsN);\n};\n\n/**\n * Formats the code with correct HTML structure to be displayed in the code div\n * TODO: implement this function\n * @param {string} code the code text to be formatted (string literal)\n * @param {number} inputFuncDecsN the number of forced input function declarations\n * @param {boolean} debugMode whether to display the code as is, or with the wrapper function\n * @returns {string} the formatted code\n */\nconst formatCodeHTML = (code, inputFuncDecsN, debugMode = true) => {\n    if (!debugMode) {\n        code = removeForcedInputFunctions(code, inputFuncDecsN);\n        code = removeOutputString(code);\n        code = removeCustomFunctions(code);\n        code = removeWrapperFunction(code);\n        return \"<pre>\" + code + \"</pre>\";\n    } else {\n        // Code is string literal\n        return \"<pre>\" + code + \"</pre>\";\n    }\n};\n\n/**\n * @param {string} code the code to be modified\n * @param {number} inputFuncDecsN the number of forced input function declarations\n * @returns {string} the code without the forced input function declarations\n */\nfunction removeForcedInputFunctions(code, inputFuncDecsN) {\n    const lines = code.split('\\n');\n    lines.splice(0, inputFuncDecsN * 3);\n    return lines.join('\\n');\n}\n\n/**\n * Removes the wrapper function from the code for presentation purposes\n * Removes first two and last three lines\n * @param {String} code the code to be modified\n * @returns {String} the code without the wrapper function\n */\n// eslint-disable-next-line no-unused-vars\nconst removeWrapperFunction = (code) => {\n    const lines = code.split('\\n');\n    lines.splice(0, 2);\n    lines.splice(-3);\n    return lines.join('\\n');\n};\n\nconst removeCustomFunctions = (code) => {\n    const lines = code.split('\\n');\n    lines.splice(0, 6);\n    return lines.join('\\n');\n};\n\nconst removeOutputString = (code) => {\n    const lines = code.split('\\n');\n    lines.splice(0, 1);\n    return lines.join('\\n');\n};\n\n/**\n * Runs the tests on the given workspace and returns an array of booleans, one for each test, indicating whether\n * the test passed or not\n * @param {String} code the workspace to run the tests on\n * @param {{}} tests the tests to run\n * @returns {String[]} the results of each test\n */\nexport const runTests = (code, tests) => {\n    let results = [];\n    tests.forEach((test) => {\n        let thisTestCode = code; // Need to copy, so that the code is not modified for the next test\n        const inputs = test.inputs;\n        inputs.forEach((input) => {\n            const prompt = Object.keys(input)[0];\n            const values = input[prompt];\n\n            const inputIndex = thisTestCode.lastIndexOf(prompt);\n            // Get the indexes of the first and second parentheses of the input function call\n            let inputParentheses1 = thisTestCode.indexOf('(', inputIndex);\n            const inputParentheses2 = thisTestCode.indexOf(')', inputParentheses1 + 1);\n\n            const preStr = thisTestCode.substring(0, inputParentheses1 + 1);\n            const postStr = thisTestCode.substring(inputParentheses2);\n\n            thisTestCode = preStr + values[0] + postStr;\n\n        });\n        // eslint-disable-next-line no-eval\n        let codeOutput = silentRunCode(thisTestCode);\n        codeOutput = codeOutput.replace(/\\s/g, '');\n        const result = codeOutput;\n        results.push(result);\n    });\n    return results;\n};\n\n/**\n * @param {String} code the code to check for input function calls\n * @param {string} inputFuncDecs the function declarations for the forced input functions\n * @returns {String[]} whether the code has all input function calls\n */\nexport function getMissingInputCalls(code, inputFuncDecs) {\n    // Regex to match input function calls outside of comments\n    const regex = /((?!\\/\\/ ).{3}|^.{0,2})\\binput\\w+\\s*\\([^)]*\\)(?=\\s*;|\\s*\\)|\\s*[,)])/g;\n    const functionDecNames = extractFunctionNames(inputFuncDecs);\n    const matches = code.match(regex);\n\n    if (matches === null) {\n        return functionDecNames;\n    }\n    const functionCallNames = matches.map((match) => match.match(/\\b(\\w+)(?=\\s*\\()/g)).flat();\n\n    //return all function declarations that are not called\n    return functionDecNames.filter((name) => !functionCallNames.includes(name));\n}\n\n/**\n * @param {String} input the code to extract the function names from\n * @returns {String[]} the names of the functions declared in the given code\n */\n// eslint-disable-next-line no-unused-vars\nfunction extractFunctionNames(input) {\n    const regex = /function\\s+(\\w+)\\s*\\(/g;\n    const functionNames = [];\n    let match;\n\n    while ((match = regex.exec(input)) !== null) {\n        functionNames.push(match[1]);\n    }\n\n    return functionNames;\n}\n\n/**\n * @param {String} code The Javascript code to be run\n * @returns {any} The output of the code\n * Runs the code and returns the output, does not display it\n * TODO: do something other than use eval\n */\nexport function silentRunCode(code) {\n    // eslint-disable-next-line no-eval\n    return eval(code);\n}\n\n/**\n * @param {WorkspaceSvg} workspace the workspace to get the code from\n * @param {string} inputFuncDecs\n * @returns {string} the code generated by Blockly for the current workspace\n *\n * Returns the Javascript code string generated by Blockly, with the necessary wrapping code\n */\nexport const getWorkspaceCode = (workspace, inputFuncDecs) => {\n    let code = javascript.javascriptGenerator.workspaceToCode(workspace);\n    javascript.javascriptGenerator.addReservedWords(\"print, input\");\n    const preamble = inputFuncDecs + `\\nlet outputString = \\`\\`;\\n\nfunction print(string) {\n    outputString += string + '\\\\n';\n}\nfunction input(prompt) {\n    return prompt;\n}\n(function () {\n    `;\n    const postscript = `return outputString;\n})();\\n`;\n\n    code = preamble;\n    let blocks = workspace.getTopBlocks(true);\n    for (var b = 0; b < blocks.length; b++) {\n        var block = blocks[b];\n\n        if (block.type === 'start') {\n            code += generateDescendantsCode(block);\n            break;\n        }\n    }\n    code += postscript;\n    return code;\n};\n\n/**\n * @param {BlockSVG} block the block whose descendants are to have their code generated\n * @returns {string} the code generated by Blockly for the descendants of the given block\n */\nfunction generateDescendantsCode(block) {\n    let descendants = block.getChildren(true);\n    let descendantsCode = '';\n    for (let i = 0; i < descendants.length; i++) {\n        let descendant = descendants[i];\n        descendantsCode += Blockly.JavaScript.blockToCode(descendant);\n    }\n    return descendantsCode;\n}\n\n/**\n * Inserts the test results accordion in the area above the Run and Tests buttons\n * @param {any[]|null} results the results of the tests (pass/fail)\n * @param {{}} testsJSON the tests that were run (for displaying the inputs and outputs)\n * @param {String[]} uncalledInputFuncs the input functions that were not called. Note: if this is not empty, results is null\n * @returns {string} the HTML for the accordion\n */\nexport const testsAccordion = (results, testsJSON, uncalledInputFuncs) => {\n\n    const testCaseCount = testsJSON.length;\n\n    let accordion = '<div style=\"max-height: 100%; overflow-y: auto;\">';\n    if (results === null) {\n        accordion += '<div class=\"alert alert-warning\" role=\"alert\">';\n        accordion += 'Not all input functions were called. No tests will be run.';\n        // Show which input functions were not called\n        accordion += '<br>Input functions not called: ' + uncalledInputFuncs.join(', ');\n        accordion += '</div>';\n    }\n\n    for (let i = 0; i < testCaseCount; i++) {\n        accordion += '<details class=\"card\">';\n        accordion += '<summary class=\"card-header\">';\n        accordion += 'Test ' + (i + 1);\n        // Show if test passed or failed\n        if (results === null || results[i] === undefined){\n            accordion += '<span class=\"badge badge-warning float-right\">Not run</span>';\n        } else if (results[i] === testsJSON[i].output) {\n            accordion += '<span class=\"badge badge-success float-right\">Passed</span>';\n        } else {\n            accordion += '<span class=\"badge badge-danger float-right\">Failed</span>';\n        }\n        accordion += '</summary>';\n        accordion += '<div class=\"card-body pt-0 pb-0 pl-2 pr-2\">';\n        // eslint-disable-next-line no-loop-func\n        testsJSON[i].inputs.forEach((input) => {\n            for (const key in input) {\n                accordion += '<p class=\"pt-2 m-0\">' + key + ': </p>';\n                accordion += '<pre class=\"mt-1 mb-0 test-input\">' + input[key][0] + '</pre>';\n            }\n        });\n        accordion += '<p class=\"pt-2 border-top mt-2 mb-0\">Test output: </p>';\n        accordion += '<pre class=\"mt-1 mb-0 mr-0 ml-0 test-output\">' + testsJSON[i].output + '</pre>';\n        accordion += '<div class=\"p-0\">';\n        accordion += '<p class=\"pt-2 m-0\">Your output: </p>';\n        if (results === null) {\n            accordion += '<pre class=\"mt-1 mb-0 mr-0 ml-0 test-output\">Not run</pre>';\n        } else {\n            accordion += '<pre class=\"pb-2 mt-1 mb-0 ml-0 mr-0 test-output\">' + results[i] + '</pre>';\n        }\n        accordion += '</div>';\n        accordion += '</details>';\n    }\n\n    accordion += '</div>';\n    return accordion;\n};\n"],"names":["injectInputBox","i","inputBox","document","createElement","setAttribute","submitButton","innerHTML","getElementById","insertAdjacentElement","replaceCode","code","inputFuncDecsN","formatCodeHTML","debugMode","removeForcedInputFunctions","removeOutputString","removeCustomFunctions","removeWrapperFunction","lines","split","splice","join","runTests","tests","results","forEach","test","thisTestCode","inputs","input","prompt","Object","keys","values","inputIndex","lastIndexOf","inputParentheses1","indexOf","inputParentheses2","preStr","substring","postStr","codeOutput","silentRunCode","result","replace","push","getMissingInputCalls","inputFuncDecs","functionDecNames","extractFunctionNames","matches","match","functionCallNames","map","flat","filter","name","includes","regex","functionNames","exec","eval","getWorkspaceCode","workspace","javascript","javascriptGenerator","workspaceToCode","addReservedWords","blocks","getTopBlocks","b","length","block","type","generateDescendantsCode","descendants","getChildren","descendantsCode","descendant","Blockly","JavaScript","blockToCode","testsAccordion","testsJSON","uncalledInputFuncs","testCaseCount","accordion","undefined","output","key"],"mappings":"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"}