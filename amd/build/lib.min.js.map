{"version":3,"file":"lib.min.js","sources":["../src/lib.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/env\n * @copyright   2023 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Injects the box for inserting the program input below the blockly area\n * @param {Number} i the index of the input box, to avoid repetition of ids\n */\nexport const injectInputBox = (i) => {\n    // Create input box for program input\n    const inputBox = document.createElement('input');\n    inputBox.setAttribute('type', 'text');\n    inputBox.setAttribute('id', 'programInputBox' + i);\n\n    // Create button to submit input\n    const submitButton = document.createElement('button');\n    submitButton.setAttribute('id', 'programInputButton' + i);\n    submitButton.setAttribute('type', 'button');\n    submitButton.innerHTML = 'Submit';\n\n    // Insert input box and button below blockly area\n    const blocklyDiv = document.getElementById('blocklyDiv');\n    blocklyDiv.insertAdjacentElement('afterend', inputBox);\n    inputBox.insertAdjacentElement('afterend', submitButton);\n};\n\n/**\n * Inserts the new program code in the code div below the blockly area, replacing the old one if it exists\n * @param {String} code the new program code to be displayed\n */\nexport const replaceCode = (code) => {\n    const codeDiv = document.getElementById('codeDiv');\n    codeDiv.innerHTML = formatCodeHTML(code);\n};\n\n/**\n * Formats the code with correct html structure to be displayed in the code div\n * TODO: implement this function\n * @param {String} code the code text to be formatted (string literal)\n * @returns {String} the formatted code\n */\nconst formatCodeHTML = (code) => {\n    // Code is string literal\n    return \"<pre>\" + code + \"</pre>\";\n};\n\n// Maybe in the future write regular expression to validate the tests file\n// Consider doing parsing on the server side, when the file is submitted\n// TODO a more formal file format description\n/**\n * Parses the tests file and returns a json object with the tests data\n * @param {String} fileString the string containing the contents of the tests file\n * @returns {{}} A JSON object with the tests data\n */\nexport const parseTestsFile = (fileString) => {\n    try {\n        // The returned object has a list of test cases\n        let jsonReturn = [];\n\n        // Different test cases are separated by |\n        let testCases = fileString.split(\"|\");\n\n        testCases.forEach((testCase) => {\n            // Each test case contains a list of inputs (and an output)\n            let thisTestCaseJson = {};\n            thisTestCaseJson.inputs = [];\n\n            // The input and output of the test are separated by -\n            let inputOutput = testCase.split(\"-\");\n            let inputs = inputOutput[0];\n            thisTestCaseJson.output = inputOutput[1].trim(); // Remove newlines and add output of test to JSON\n\n            inputs.split(\"_\").forEach((input) => {\n                if (input.length < 3) { // Skip junk elements\n                    return;\n                }\n                // Each input has multiple lines. The first line is the input name, the prompt, and the rest are\n                // the input values for that input\n                let inputLines = input.split(/\\n/).map((line) => line.trim()); // Remove junk line breaks from every line\n                inputLines = inputLines.slice(1, inputLines.length - 1); // First and last lines are junk\n                // Contains the input prompt and a list of input values\n                let thisInputJson = {};\n                thisInputJson[inputLines[0]] = inputLines.slice(1);\n                thisTestCaseJson.inputs.push(thisInputJson); // Add this input to the list of inputs of this test case\n            });\n            jsonReturn.push(thisTestCaseJson); // Add this test case to the list of test cases\n        });\n        return jsonReturn;\n    } catch (e) {\n        throw new Error(\"Error parsing tests file: \" + e);\n    }\n};\n\n// eslint-disable-next-line no-unused-vars\nexport const runTests = (contents) => {\n    // eslint-disable-next-line no-unused-vars\n    const tests = parseTestsFile(contents);\n    // eslint-disable-next-line no-console\n    console.log(tests);\n};"],"names":["i","inputBox","document","createElement","setAttribute","submitButton","innerHTML","getElementById","insertAdjacentElement","code","formatCodeHTML","parseTestsFile","fileString","jsonReturn","split","forEach","testCase","thisTestCaseJson","inputOutput","inputs","output","trim","input","length","inputLines","map","line","thisInputJson","slice","push","e","Error","contents","tests","console","log"],"mappings":"0OAW8B,SAACA,OAErBC,SAAWC,SAASC,cAAc,SACxCF,SAASG,aAAa,OAAQ,QAC9BH,SAASG,aAAa,KAAM,kBAAoBJ,OAG1CK,aAAeH,SAASC,cAAc,UAC5CE,aAAaD,aAAa,KAAM,qBAAuBJ,GACvDK,aAAaD,aAAa,OAAQ,UAClCC,aAAaC,UAAY,SAGNJ,SAASK,eAAe,cAChCC,sBAAsB,WAAYP,UAC7CA,SAASO,sBAAsB,WAAYH,oCAOpB,SAACI,MACRP,SAASK,eAAe,WAChCD,UAAYI,eAAeD,WASjCC,eAAiB,SAACD,YAEb,QAAUA,KAAO,UAWfE,eAAiB,SAACC,oBAGnBC,WAAa,UAGDD,WAAWE,MAAM,KAEvBC,SAAQ,SAACC,cAEXC,iBAAmB,CACvBA,OAA0B,IAGtBC,YAAcF,SAASF,MAAM,KAC7BK,OAASD,YAAY,GACzBD,iBAAiBG,OAASF,YAAY,GAAGG,OAEzCF,OAAOL,MAAM,KAAKC,SAAQ,SAACO,YACnBA,MAAMC,OAAS,QAKfC,WAAaF,MAAMR,MAAM,MAAMW,KAAI,SAACC,aAASA,KAAKL,UAGlDM,cAAgB,GACpBA,eAHAH,WAAaA,WAAWI,MAAM,EAAGJ,WAAWD,OAAS,IAG5B,IAAMC,WAAWI,MAAM,GAChDX,iBAAiBE,OAAOU,KAAKF,mBAEjCd,WAAWgB,KAAKZ,qBAEbJ,WACT,MAAOiB,SACC,IAAIC,MAAM,6BAA+BD,8DAK/B,SAACE,cAEfC,MAAQtB,eAAeqB,UAE7BE,QAAQC,IAAIF"}