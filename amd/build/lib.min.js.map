{"version":3,"file":"lib.min.js","sources":["../src/lib.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/lib\n * @copyright   2023 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/* globals Blockly */\n\n/* globals javascript */\n\ndefine(['mod_nextblocks/codestring'], function(CodeString) {\n    /**\n     * @param {BlockSvg} block the block whose code is to be generated\n     * @returns {string} the code generated by Blockly for the given block\n     */\n    function generateFunctionCode(block) {\n        Blockly.JavaScript.blockToCode(block);\n        // Get function name\n        let functionName = '%' + javascript.javascriptGenerator.nameDB_.getName(block.getFieldValue('NAME'),\n            Blockly.Procedures.NAME_TYPE);\n        functionName = functionName.substring(0, functionName.length - 1);\n        return javascript.javascriptGenerator.definitions_[functionName] + '\\n';\n    }\n\n    /**\n     * @param {BlockSvg} block the block whose descendants are to have their code generated\n     * @returns {string} the code generated by Blockly for the descendants of the given block\n     */\n    function generateDescendantsCode(block) {\n        let descendantsCode = '';\n        block.getChildren(true).forEach((child) => {\n            descendantsCode += Blockly.JavaScript.blockToCode(child);\n        });\n        return descendantsCode;\n    }\n\n    /**\n     * @param {String} input the code to extract the function names from\n     * @returns {String[]} the names of the functions declared in the given code\n     */\n    function extractFunctionNames(input) {\n        const regex = /function\\s+(\\w+)\\s*\\(/g;\n        const functionNames = [];\n        let match;\n\n        while ((match = regex.exec(input)) !== null) {\n            functionNames.push(match[1]);\n        }\n\n        return functionNames;\n    }\n\n    return {\n        /**\n         * @param {String} code The Javascript code to be run\n         * @returns {any} The output of the code\n         * Runs the code and returns the output, does not display it\n         * TODO: do something other than use eval\n         */\n        silentRunCode: function(code) {\n            // eslint-disable-next-line no-eval\n            return eval(code);\n        },\n\n        /**\n         * Formats the code with correct HTML structure to be displayed in the code div\n         * TODO: implement this function\n         * @param {CodeString} code the code text to be formatted (string literal)\n         * @param {boolean} debugMode whether to display the code as is, or with the wrapper function\n         * @returns {string} the formatted code\n         */\n        formatCodeHTML: (code, debugMode = false) => {\n            if (!debugMode) {\n                return '<pre>' + code.getPrintableCodeString() + '</pre>';\n            } else {\n                return '<pre>' + code.getCompleteCodeString() + '</pre>';\n            }\n        },\n\n        /**\n         * Inserts the test results accordion in the area above the Run and Tests buttons\n         * @param {any[]|null} results the outputs of the tests\n         * @param {{}} testsJSON the tests that were run (for displaying the inputs and outputs)\n         * @param {String[]} uncalledInputFuncs the input functions that were not called.\n         * Note: if this is not empty, results is null\n         * @returns {string} the HTML for the accordion\n         */\n        testsAccordion: function(results, testsJSON, uncalledInputFuncs) {\n\n            const testCaseCount = testsJSON.length;\n\n            let accordion = '<div style=\"max-height: 100%; overflow-y: auto;\">';\n            if (results === null) {\n                accordion += '<div class=\"alert alert-warning\" role=\"alert\">';\n                accordion += 'Not all input functions were called. No tests will be executed.';\n                // Show which input functions were not called\n                accordion += '<br>Input functions not called: ' + uncalledInputFuncs.join(', ');\n                accordion += '</div>';\n            }\n\n            for (let i = 0; i < testCaseCount; i++) {\n                accordion += '<details class=\"card\">';\n                accordion += '<summary class=\"card-header\">';\n                accordion += 'Test ' + (i + 1);\n                // Show if test passed or failed\n                if (results === null || results[i] === undefined) {\n                    accordion += '<span class=\"badge badge-warning float-right\">Not run</span>';\n                } else if (results[i] === testsJSON[i].output) {\n                    accordion += '<span class=\"badge badge-success float-right\">Passed</span>';\n                } else {\n                    accordion += '<span class=\"badge badge-danger float-right\">Failed</span>';\n                }\n                accordion += '</summary>';\n                accordion += '<div class=\"card-body pt-0 pb-0 pl-2 pr-2\">';\n                // eslint-disable-next-line no-loop-func\n                testsJSON[i].inputs.forEach((input) => {\n                    for (const key in input) {\n                        accordion += '<p class=\"pt-2 m-0\">' + key + ': </p>';\n                        accordion += '<pre class=\"mt-1 mb-0 test-input\">' + Object.values(input[key])[0][0] + '</pre>';\n                    }\n                });\n                accordion += '<p class=\"pt-2 border-top mt-2 mb-0\">Test output: </p>';\n                accordion += '<pre class=\"mt-1 mb-0 mr-0 ml-0 test-output\">' + testsJSON[i].output + '</pre>';\n                accordion += '<div class=\"p-0\">';\n                accordion += '<p class=\"pt-2 m-0\">Your output: </p>';\n                if (results === null) {\n                    accordion += '<pre class=\"mt-1 mb-0 mr-0 ml-0 test-output\">Not run</pre>';\n                } else {\n                    accordion += '<pre class=\"pb-2 mt-1 mb-0 ml-0 mr-0 test-output\">' + results[i] + '</pre>';\n                }\n                accordion += '</div>';\n                accordion += '</details>';\n            }\n\n            accordion += '</div>';\n            return accordion;\n        },\n\n        /**\n         * Runs the tests on the given workspace and returns an array of booleans, one for each test, indicating whether\n         * the test passed or not\n         * @param {String} code the workspace to run the tests on\n         * @param {{}} tests the tests to run\n         * @returns {String[]} the output of each test\n         */\n        runTests: function(code, tests) {\n            let results = [];\n            tests.forEach((test) => {\n                let thisTestCode = code; // Need to copy, so that the code is not modified for the next test\n                const inputs = test.inputs;\n                inputs.forEach((input) => {\n                    const prompt = Object.keys(input)[0];\n                    const values = Object.values(input[prompt])[0];\n\n                    const inputIndex = thisTestCode.lastIndexOf(prompt);\n                    // Get the indexes of the first and second parentheses of the input function call\n                    const inputParentheses1 = thisTestCode.indexOf('(', inputIndex);\n                    const inputParentheses2 = thisTestCode.indexOf(')', inputParentheses1 + 1);\n\n                    const preStr = thisTestCode.substring(0, inputParentheses1 + 1);\n                    const postStr = thisTestCode.substring(inputParentheses2);\n\n                    thisTestCode = preStr + values[0] + postStr;\n                });\n                let codeOutput = this.silentRunCode(thisTestCode);\n                codeOutput = codeOutput.replace(/\\s/g, '');\n                results.push(codeOutput);\n            });\n            return results;\n        },\n\n        /**\n         * @param {String} code the code to check for input function calls\n         * @param {string} inputFuncDecs the function declarations for the forced input functions\n         * @returns {String[]} whether the code has all input function calls\n         */\n        getMissingInputCalls: function(code, inputFuncDecs) {\n\n            // Regex to match input function calls outside of comments\n            const regex = /((?!\\/\\/ ).{3}|^.{0,2})\\binput\\w+\\s*\\([^)]*\\)(?=\\s*;|\\s*\\)|\\s*[,)])/g;\n            const functionDecNames = extractFunctionNames(inputFuncDecs);\n            const matches = code.match(regex);\n\n            if (matches === null) {\n                return functionDecNames;\n            }\n            const functionCallNames = matches.map((match) => match.match(/\\b(\\w+)(?=\\s*\\()/g)).flat();\n\n            // Return all function declarations that are not called\n            return functionDecNames.filter((name) => !functionCallNames.includes(name));\n        },\n\n        /**\n         * @param {WorkspaceSvg} workspace the workspace to get the code from\n         * @param {string} inputFuncDecs\n         * @returns {CodeString} the code generated by Blockly for the current workspace\n         *\n         * Returns the Javascript code string generated by Blockly, with the necessary wrapping code\n         */\n        getWorkspaceCode: function(workspace, inputFuncDecs) {\n            javascript.javascriptGenerator.addReservedWords('print, input');\n            let codeString = new CodeString();\n\n            codeString.addAuxFunctions(inputFuncDecs);\n            codeString.addVariable('outputString', '\"\"');\n\n            const functionOpen = '(function () {';\n            codeString.addLine(functionOpen);\n\n            let blocks = workspace.getTopBlocks(true);\n            for (let b = 0; b < blocks.length; b++) {\n                const block = blocks[b];\n                if (block.type === 'start') {\n                    codeString.addMainCode(generateDescendantsCode(block));\n                } else if (block.type === 'procedures_defnoreturn' || block.type === 'procedures_defreturn') {\n                    codeString.addFunction(generateFunctionCode(block));\n                }\n            }\n            codeString.addEnding();\n            return codeString;\n        },\n    };\n});\n"],"names":["define","CodeString","generateFunctionCode","block","Blockly","JavaScript","blockToCode","functionName","javascript","javascriptGenerator","nameDB_","getName","getFieldValue","Procedures","NAME_TYPE","substring","length","definitions_","generateDescendantsCode","descendantsCode","getChildren","forEach","child","extractFunctionNames","input","match","regex","functionNames","exec","push","silentRunCode","code","eval","formatCodeHTML","debugMode","getCompleteCodeString","getPrintableCodeString","testsAccordion","results","testsJSON","uncalledInputFuncs","testCaseCount","accordion","join","i","undefined","output","inputs","key","Object","values","runTests","tests","test","thisTestCode","prompt","keys","inputIndex","lastIndexOf","inputParentheses1","indexOf","inputParentheses2","preStr","postStr","codeOutput","_this","replace","getMissingInputCalls","inputFuncDecs","functionDecNames","matches","functionCallNames","map","flat","filter","name","includes","getWorkspaceCode","workspace","addReservedWords","codeString","addAuxFunctions","addVariable","addLine","blocks","getTopBlocks","b","type","addMainCode","addFunction","addEnding"],"mappings":"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"}