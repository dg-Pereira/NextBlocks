{"version":3,"file":"lib.min.js","sources":["../src/lib.js"],"sourcesContent":["/**\n *\n * @module      mod_nextblocks/lib\n * @copyright   2023 Duarte Pereira<dg.pereira@campus.fct.unl.pt>\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/* globals Blockly */\n\n/* globals javascript */\n\ndefine(['mod_nextblocks/codestring'], function(CodeString) {\n    /**\n     * @param {BlockSvg} block the block whose code is to be generated\n     * @returns {string} the code generated by Blockly for the given block\n     */\n    function generateFunctionCode(block) {\n        Blockly.JavaScript.blockToCode(block);\n        // Get function name\n        let functionName = \"%\" + javascript.javascriptGenerator.nameDB_.getName(block.getFieldValue('NAME'),\n            Blockly.Procedures.NAME_TYPE);\n        functionName = functionName.substring(0, functionName.length - 1);\n        return javascript.javascriptGenerator.definitions_[functionName] + '\\n';\n    }\n\n    /**\n     * @param {BlockSvg} block the block whose descendants are to have their code generated\n     * @returns {string} the code generated by Blockly for the descendants of the given block\n     */\n    function generateDescendantsCode(block) {\n        let descendants = block.getChildren(true);\n        let descendantsCode = '';\n        for (let i = 0; i < descendants.length; i++) {\n            let descendant = descendants[i];\n            descendantsCode += Blockly.JavaScript.blockToCode(descendant);\n        }\n        return descendantsCode;\n    }\n\n    /**\n     * @param {String} input the code to extract the function names from\n     * @returns {String[]} the names of the functions declared in the given code\n     */\n    function extractFunctionNames(input) {\n        const regex = /function\\s+(\\w+)\\s*\\(/g;\n        const functionNames = [];\n        let match;\n\n        while ((match = regex.exec(input)) !== null) {\n            functionNames.push(match[1]);\n        }\n\n        return functionNames;\n    }\n\n    /**\n     * Formats the code with correct HTML structure to be displayed in the code div\n     * TODO: implement this function\n     * @param {CodeString} code the code text to be formatted (string literal)\n     * @param {boolean} debugMode whether to display the code as is, or with the wrapper function\n     * @returns {string} the formatted code\n     */\n    const formatCodeHTML = (code, debugMode = true) => {\n        if (!debugMode) {\n            return \"<pre>\" + code.getPrintableCodeString() + \"</pre>\";\n        } else {\n            return \"<pre>\" + code.getCompleteCodeString() + \"</pre>\";\n        }\n    };\n\n    return {\n        /**\n         * @param {String} code The Javascript code to be run\n         * @returns {any} The output of the code\n         * Runs the code and returns the output, does not display it\n         * TODO: do something other than use eval\n         */\n        silentRunCode: function(code) {\n            // eslint-disable-next-line no-eval\n            return eval(code);\n        },\n\n        /**\n         * Inserts the new program code in the code div below the blockly area, replacing the old one if it exists\n         * @param {CodeString} code the new program code to be displayed\n         */\n        replaceCode: function(code) {\n            const codeDiv = document.getElementById('codeDiv');\n            codeDiv.innerHTML = formatCodeHTML(code);\n        },\n\n        /**\n         * Inserts the test results accordion in the area above the Run and Tests buttons\n         * @param {any[]|null} results the results of the tests (pass/fail)\n         * @param {{}} testsJSON the tests that were run (for displaying the inputs and outputs)\n         * @param {String[]} uncalledInputFuncs the input functions that were not called.\n         * Note: if this is not empty, results is null\n         * @returns {string} the HTML for the accordion\n         */\n        testsAccordion: function(results, testsJSON, uncalledInputFuncs) {\n\n            const testCaseCount = testsJSON.length;\n\n            let accordion = '<div style=\"max-height: 100%; overflow-y: auto;\">';\n            if (results === null) {\n                accordion += '<div class=\"alert alert-warning\" role=\"alert\">';\n                accordion += 'Not all input functions were called. No tests will be run.';\n                // Show which input functions were not called\n                accordion += '<br>Input functions not called: ' + uncalledInputFuncs.join(', ');\n                accordion += '</div>';\n            }\n\n            for (let i = 0; i < testCaseCount; i++) {\n                accordion += '<details class=\"card\">';\n                accordion += '<summary class=\"card-header\">';\n                accordion += 'Test ' + (i + 1);\n                // Show if test passed or failed\n                if (results === null || results[i] === undefined) {\n                    accordion += '<span class=\"badge badge-warning float-right\">Not run</span>';\n                } else if (results[i] === testsJSON[i].output) {\n                    accordion += '<span class=\"badge badge-success float-right\">Passed</span>';\n                } else {\n                    accordion += '<span class=\"badge badge-danger float-right\">Failed</span>';\n                }\n                accordion += '</summary>';\n                accordion += '<div class=\"card-body pt-0 pb-0 pl-2 pr-2\">';\n                // eslint-disable-next-line no-loop-func\n                testsJSON[i].inputs.forEach((input) => {\n                    for (const key in input) {\n                        accordion += '<p class=\"pt-2 m-0\">' + key + ': </p>';\n                        accordion += '<pre class=\"mt-1 mb-0 test-input\">' + input[key][0] + '</pre>';\n                    }\n                });\n                accordion += '<p class=\"pt-2 border-top mt-2 mb-0\">Test output: </p>';\n                accordion += '<pre class=\"mt-1 mb-0 mr-0 ml-0 test-output\">' + testsJSON[i].output + '</pre>';\n                accordion += '<div class=\"p-0\">';\n                accordion += '<p class=\"pt-2 m-0\">Your output: </p>';\n                if (results === null) {\n                    accordion += '<pre class=\"mt-1 mb-0 mr-0 ml-0 test-output\">Not run</pre>';\n                } else {\n                    accordion += '<pre class=\"pb-2 mt-1 mb-0 ml-0 mr-0 test-output\">' + results[i] + '</pre>';\n                }\n                accordion += '</div>';\n                accordion += '</details>';\n            }\n\n            accordion += '</div>';\n            return accordion;\n        },\n\n        /**\n         * Runs the tests on the given workspace and returns an array of booleans, one for each test, indicating whether\n         * the test passed or not\n         * @param {String} code the workspace to run the tests on\n         * @param {{}} tests the tests to run\n         * @returns {String[]} the output of each test\n         */\n        runTests: function(code, tests) {\n            let results = [];\n            // eslint-disable-next-line no-console\n            console.log(code);\n            tests.forEach((test) => {\n                let thisTestCode = code; // Need to copy, so that the code is not modified for the next test\n                const inputs = test.inputs;\n                inputs.forEach((input) => {\n                    const prompt = Object.keys(input)[0];\n                    const values = Object.values(input[prompt])[0];\n\n                    const inputIndex = thisTestCode.lastIndexOf(prompt);\n                    // Get the indexes of the first and second parentheses of the input function call\n                    const inputParentheses1 = thisTestCode.indexOf('(', inputIndex);\n                    const inputParentheses2 = thisTestCode.indexOf(')', inputParentheses1 + 1);\n\n                    // eslint-disable-next-line no-console\n                    console.log(thisTestCode);\n                    // eslint-disable-next-line no-console\n                    console.log(inputParentheses1, inputParentheses2);\n                    const preStr = thisTestCode.substring(0, inputParentheses1 + 1);\n                    const postStr = thisTestCode.substring(inputParentheses2);\n\n                    thisTestCode = preStr + values[0] + postStr;\n                });\n                let codeOutput = this.silentRunCode(thisTestCode);\n                codeOutput = codeOutput.replace(/\\s/g, '');\n                const result = codeOutput;\n                results.push(result);\n            });\n            return results;\n        },\n\n        /**\n         * @param {String} code the code to check for input function calls\n         * @param {string} inputFuncDecs the function declarations for the forced input functions\n         * @returns {String[]} whether the code has all input function calls\n         */\n        getMissingInputCalls: function(code, inputFuncDecs) {\n\n            // Regex to match input function calls outside of comments\n            const regex = /((?!\\/\\/ ).{3}|^.{0,2})\\binput\\w+\\s*\\([^)]*\\)(?=\\s*;|\\s*\\)|\\s*[,)])/g;\n            const functionDecNames = extractFunctionNames(inputFuncDecs);\n            const matches = code.match(regex);\n\n            if (matches === null) {\n                return functionDecNames;\n            }\n            const functionCallNames = matches.map((match) => match.match(/\\b(\\w+)(?=\\s*\\()/g)).flat();\n\n            // Return all function declarations that are not called\n            return functionDecNames.filter((name) => !functionCallNames.includes(name));\n        },\n\n        /**\n         * @param {WorkspaceSvg} workspace the workspace to get the code from\n         * @param {string} inputFuncDecs\n         * @returns {CodeString} the code generated by Blockly for the current workspace\n         *\n         * Returns the Javascript code string generated by Blockly, with the necessary wrapping code\n         */\n        getWorkspaceCode: function(workspace, inputFuncDecs) {\n            javascript.javascriptGenerator.addReservedWords(\"print, input\");\n            let codeString = new CodeString();\n\n            codeString.addAuxFunctions(inputFuncDecs);\n            codeString.addVariable('outputString', '\"\"');\n\n            const functionOpen = \"(function () {\";\n            codeString.addLine(functionOpen);\n\n            let blocks = workspace.getTopBlocks(true);\n            for (let b = 0; b < blocks.length; b++) {\n                const block = blocks[b];\n                if (block.type === 'start') {\n                    codeString.addMainCode(generateDescendantsCode(block));\n                }\n                if (block.type === 'procedures_defnoreturn' || block.type === 'procedures_defreturn') {\n                    codeString.addFunction(generateFunctionCode(block));\n                }\n            }\n            codeString.addEnding();\n            return codeString;\n        },\n    };\n});\n"],"names":["define","CodeString","generateFunctionCode","block","Blockly","JavaScript","blockToCode","functionName","javascript","javascriptGenerator","nameDB_","getName","getFieldValue","Procedures","NAME_TYPE","substring","length","definitions_","generateDescendantsCode","descendants","getChildren","descendantsCode","i","descendant","extractFunctionNames","input","match","regex","functionNames","exec","push","formatCodeHTML","code","debugMode","getCompleteCodeString","getPrintableCodeString","silentRunCode","eval","replaceCode","document","getElementById","innerHTML","testsAccordion","results","testsJSON","uncalledInputFuncs","testCaseCount","accordion","join","undefined","output","inputs","forEach","key","runTests","tests","console","log","test","thisTestCode","prompt","Object","keys","values","inputIndex","lastIndexOf","inputParentheses1","indexOf","inputParentheses2","preStr","postStr","codeOutput","_this","result","replace","getMissingInputCalls","inputFuncDecs","functionDecNames","matches","functionCallNames","map","flat","filter","name","includes","getWorkspaceCode","workspace","addReservedWords","codeString","addAuxFunctions","addVariable","addLine","blocks","getTopBlocks","b","type","addMainCode","addFunction","addEnding"],"mappings":"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"}